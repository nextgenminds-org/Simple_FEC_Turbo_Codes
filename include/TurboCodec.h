#ifndef TURBO_CODEC_H
#define TURBO_CODEC_H

#include <vector>
#include <string>
#include <cstdint>
#include <limits>

// Utility functions

/**
 * @brief Computes the absolute value of a number.
 * @tparam T The type of the number (e.g., int, float, double).
 * @param x The input number.
 * @return The absolute value of x.
 */
template <typename T>
constexpr T abs(T x);

/**
 * @brief Generates a random interleaver, which is a permutation of indices.
 *        Used for scrambling input bits in turbo encoding to improve error resilience.
 * @param length The length of the interleaver.
 * @return A vector containing a permutation of indices [0, length-1].
 */
std::vector<size_t> generateInterleaver(size_t length);

/**
 * @brief Converts a string into a binary representation.
 * @param input The input string.
 * @return A vector of 0s and 1s representing the binary encoding of the string.
 */
std::vector<uint8_t> stringToBinary(const std::string& input);

/**
 * @brief Converts a binary representation back to a string.
 * @param binary A vector of 0s and 1s representing a binary-encoded string.
 * @return The decoded string.
 */
std::string binaryToString(const std::vector<uint8_t>& binary);

// ConvolutionalCode class
/**
 * @brief A class representing a recursive systematic convolutional (RSC) encoder and decoder.
 *        It handles both the encoding of input bits and decoding using algorithms such as BCJR, MAP, and SOVA.
 */
class ConvolutionalCode {
private:
    uint32_t n;                           // Number of output bits per input bit (rate = 1/n).
    uint32_t m;                           // Memory size of the encoder (number of shift registers).
    uint32_t state;                       // Current state of the encoder.
    std::vector<uint32_t> generators;     // Generator polynomials defining the code.

    /**
     * @brief Computes the next state of the encoder based on the current state and input bit.
     * @param currentState The current state of the encoder.
     * @param input The input bit (0 or 1).
     * @return The next state of the encoder.
     */
    uint32_t computeNextState(uint32_t currentState, bool input);

    /**
     * @brief Computes the output bits generated by the encoder for a given state and input bit.
     * @param currentState The current state of the encoder.
     * @param input The input bit (0 or 1).
     * @return The output bits as an integer.
     */
    uint8_t computeNextOutput(uint32_t currentState, bool input);

public:
    /**
     * @brief Constructor for the ConvolutionalCode class.
     * @param n The number of output bits per input bit.
     * @param m The memory size of the encoder.
     * @param gen The generator polynomials defining the code.
     */
    ConvolutionalCode(uint32_t n, uint32_t m, const std::vector<uint32_t>& gen);

    /**
     * @brief Resets the internal state of the encoder to the initial state.
     */
    void reset();

    /**
     * @brief Encodes a sequence of input bits using the convolutional encoder.
     * @param input A vector of input bits (0s and 1s).
     * @return A vector of pairs representing systematic and parity bits.
     */
    std::vector<std::pair<uint8_t, uint8_t>> encode(const std::vector<uint8_t>& input);

    /**
     * @brief Decodes a sequence of received bits using the BCJR algorithm.
     * @param systematic The systematic bits received.
     * @param parity The parity bits received.
     * @param extrinsic The extrinsic information from previous iterations.
     * @param noiseVariance The variance of the noise in the channel.
     * @return A vector of log-likelihood ratios (LLRs) for the decoded bits.
     */
    std::vector<double> decodeBCJR(const std::vector<double>& systematic,
                                   const std::vector<double>& parity,
                                   const std::vector<double>& extrinsic,
                                   double noiseVariance);

    /**
     * @brief Decodes a sequence of received bits using the MAP algorithm.
     * @param systematic The systematic bits received.
     * @param parity The parity bits received.
     * @param extrinsic The extrinsic information from previous iterations.
     * @param noiseVariance The variance of the noise in the channel.
     * @return A vector of log-likelihood ratios (LLRs) for the decoded bits.
     */
    std::vector<double> decodeMAP(const std::vector<double>& systematic,
                                  const std::vector<double>& parity,
                                  const std::vector<double>& extrinsic,
                                  double noiseVariance);

    /**
     * @brief Decodes a sequence of received bits using the SOVA algorithm.
     * @param systematic The systematic bits received.
     * @param parity The parity bits received.
     * @param extrinsic The extrinsic information from previous iterations.
     * @param noiseVariance The variance of the noise in the channel.
     * @return A vector of log-likelihood ratios (LLRs) for the decoded bits.
     */
    std::vector<double> decodeSOVA(const std::vector<double>& systematic,
                                   const std::vector<double>& parity,
                                   const std::vector<double>& extrinsic,
                                   double noiseVariance);
};

// TurboCodec class
/**
 * @brief A class representing the Turbo Codec system, including turbo encoding and decoding.
 *        This class integrates two convolutional encoders and supports various decoding algorithms.
 */
class TurboCodec {
private:
    ConvolutionalCode encoder1, encoder2; // Two convolutional encoders used in parallel.
    int maxIterations;                   // Maximum number of decoding iterations.
    double convergenceThreshold;         // Threshold for convergence during iterative decoding.

public:
    /**
     * @brief Constructor for the TurboCodec class.
     *        Initializes the encoders and sets default values for maxIterations and convergenceThreshold.
     */
    TurboCodec();

    /**
     * @brief Encodes an input string into a turbo-encoded string.
     * @param input The input string to encode.
     * @param output The encoded output string.
     */
    void encode(const std::string& input, std::string& output);

    /**
     * @brief Decodes a turbo-encoded string using the specified decoding algorithm.
     * @param input The encoded input string.
     * @param output The decoded output string.
     * @param noiseVariance The variance of the noise in the channel.
     * @param algorithm The decoding algorithm to use ("BCJR", "MAP", "SOVA", or "HYBRID").
     */
    void decode(const std::string& input, std::string& output, double noiseVariance, const std::string& algorithm);

    /**
     * @brief Sets the maximum number of decoding iterations.
     * @param iterations The maximum number of iterations.
     */
    void setMaxIterations(int iterations);

    /**
     * @brief Sets the convergence threshold for decoding.
     * @param threshold The convergence threshold.
     */
    void setConvergenceThreshold(double threshold);
};

#endif // TURBO_CODEC_H
